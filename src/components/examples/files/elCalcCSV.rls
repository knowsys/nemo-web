%! Ontology reasoning for OWL EL (preprocessed ontology)
%!
%! This example implements a complete reasoning algorithm for inferring all
%! subclass-of relations that follow from an ontology in the language OWL EL.
%! In this example, the ontology has been preprocessed and encoded in CSV files.
%! (There is another example that implements the preprocessing in Nemo.)
%! The ontology used here is an OWL EL version of the medical ontology "Galen".
%!
%! This example shows:
%! - how to load compressed data from online CSV files
%! - how to encode OWL reasoning rules from a research paper in simple (Datalog) rules
%!
%! The actual 11 rules used here correspond to the inference rules developed in
%! the following paper (see Figure 3):
%!
%! Y. Kazakov, M. Kr√∂tzsch, F. Simancik. The Incredible ELK: From Polynomial
%! Procedures to Efficient Reasoning with EL Ontologies. J Autom. Reasoning, 2014.
%! doi: 10.1007/S10817-013-9296-3

@prefix owl: <http://www.w3.org/2002/07/owl#> .

%%% Reuse same string for all imported files:
@parameter $dataDir = "https://raw.githubusercontent.com/knowsys/nemo-examples/main/examples/owl-el/from-preprocessed-csv/data/" .

%%% Import namedClass. The data contains some auxiliary class names that were created
%%% during the pre-processing. A fact namedClass(C) means that C is not auxiliary.
@import namedClass :- csv{resource = f"{$dataDir}isMainClass.csv.gz"} .

%%% Import subClassOf. A fact subClassOf(C,D) means that C is a subclass of D.
@import subClassOf :- csv{resource = f"{$dataDir}subClassOf.csv.gz"} .
%%% Import subProp. A fact subProp(R,S) means that R is a subproperty of S.
@import subProp :- csv{resource = f"{$dataDir}subProp.csv.gz"} .
%%% Import subPropChain. A fact subPropChain(R,S,T) means that R, S, and T are properties,
%%% such that R(x,y) and S(y,z), then also T(x,z), as in subPropChain(parent,brother,uncle). 
@import subPropChain :- csv{resource = f"{$dataDir}subPropChain.csv.gz"} .

%%% Import isIntersection. A fact isIntersection(C,A,B) means that class C is the
%%% intersection of A and B.
@import isIntersection :- csv{resource = f"{$dataDir}conj.csv.gz"} .
%%% Import isSomeValues. A fact isSomeValues(C,R,D) means that class C is the class of
%%% all things that have some value for property R that is an instance of class D.
@import isSomeValues :- csv{resource = f"{$dataDir}exists.csv.gz"} .

%%% Import isSubClass. A fact isSubClass(C) means that C occurs in a subclass position
%%% somewhere in the ontology.
@import isSubClass :- csv{resource = f"{$dataDir}isSubClass.csv.gz"} .

%%% Start classification for all named classes. Superclasses are only computed for
%%% classes that are "initialized".
infInit(?C) :- namedClass(?C) .

% Inference rules (from "The Incredible ELK", Fig. 3) %

%%% Rule "R_0". Every initialized class is a subclass of itself. 
infSubClassOf(?C,?C) :- infInit(?C) .

%%% Rule "R_\top". The top class owl:Thing is a superclass of all classes (especially of all named classes).
infSubClassOf(?C, owl:Thing) :- namedClass(?C), isSubClass(owl:Thing) .

%%% Rule "R_\sqcap^-". A subclass of an intersection is a subclass of both of the intersected classes.
infSubClassOf(?C,?D1), infSubClassOf(?C,?D2) :-
	infSubClassOf(?C,?Y), isIntersection(?Y,?D1,?D2) .

%%% Rule "R_\sqcap^+". If a class C is a subclass of two classes D1 and D2, and there is an intersection
%%% Y of those two classes, then C is also a subclass of Y.
infSubClassOf(?C,?Y) :-
	infSubClassOf(?C,?D1), infSubClassOf(?C,?D2),
	isIntersection(?Y,?D1,?D2), isSubClass(?Y) .

%%% Rule "R_\exists^-". If E is a subclass of a someValues-class for R and C, then
%%% every instance of E has some R-value in C (this is the intended meaning of infEx).
infEx(?E,?R,?C) :- infSubClassOf(?E,?Y), isSomeValues(?Y,?R,?C) .

%%% Rule "R_\exists^+". If E is inferred to have an S-value in D (first line), and
%%% if there is a someValues-class Y for S and D that is relevant as subclass (second line),
%%% then infer that E is a subclass of Y. 
infSubClassOf(?E,?Y) :-
	infEx(?E,?R,?C), infSubClassOf(?C,?D), subProp(?R,?S),
	isSomeValues(?Y,?S,?D), isSubClass(?Y) .

%%% R_\sqsubseteq. A subclass of a subclass is also a subclass.
infSubClassOf(?C,?E) :-	infSubClassOf(?C,?D), subClassOf(?D,?E) .

%%% Rule "R_\circ". If every E has some R1-value in C, and every C has some
%%% R2-value in D, and we have supproperty (chain) information by which R1-R2-chains
%%% lead to S, then every E has an S-value in D.
infEx(?E,?S,?D) :-
	infEx(?E,?R1,?C), infEx(?C,?R2,?D),
	subProp(?R1,?S1), subProp(?R2,?S2), subPropChain(?S1,?S2,?S) .

%%% Rule "R_\bot". If every E has some R-value in C, and C is empty (subclass of owl:Nothing),
%%% then E is also empty.
infSubClassOf(?E, owl:Nothing) :- infEx(?E,?R,?C), infSubClassOf(?C, owl:Nothing) .

%%% Rule "R_init". If every E has an R-value in C, then initialize C.
infInit(?C) :- infEx(?E,?R,?C) .

%%% Extract final results for main classes.
mainSubClassOf(?A,?B) :- infSubClassOf(?A,?B), namedClass(?A), namedClass(?B) .

%%% Output only the subclass of relation between main classes.
@output mainSubClassOf .
